<!DOCTYPE html>
<html>
    <head>
        <title>tinumuのホームページ</title>
        <link rel=stylesheet type="text/css" href="../style.css">
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
		</script>
		<script type="text/javascript"
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
		</script>
		<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
    </head>
    <body>
		<h1>ゼータ変換とメビウス変換をちょっと勉強した</h1>
		<a href="index.html"> 目次に戻る </a>
		<h2>概要</h2>
		<p>
			名前がかなり難しそうなのと、実際数式がいっぱいでてくるので(これは私が数学が弱いため)、勉強するのを敬遠してたのですが、
			<a href="https://atcoder.jp/contests/abc187/tasks/abc187_f"> ABC187F - Close Group</a> 
			という問題を彩色数を求めることで解くという解法を解説ページに書いてあったため、せっかくだしやってみようということでちょっと勉強しました。
		</p>
		<p>
			彩色数を求めるときはどうやら独立集合を $k$ 回使って $S$ の部分集合にするものの個数を求めて、これをメビウス変換すると解けるようです。
			いろいろとステップがあるので完全には理解できてはいませんが、とりあえず書けるようにはなったと思います。
			まあ彩色数の説明はここではしないんですけどね。
		</p>
		<p>
			自分用のメモでまとめる程度なので、色々間違ってたりするかもしれませんがご了承を。
		</p>
		<h2>ゼータ変換・メビウス変換</h2>
		<p>
			ある関数 $f$ と $g$ があって集合 $S$ に対してこのように定義します。
		</p>
		<p>
			$$\displaystyle f(S) = \sum_{T \subseteq S} g(T)$$
			$$g(S) = \sum_{T \subseteq S} (-1)^{|S|-|T|} f(T)$$
			このときの $f$ をゼータ変換、 $g$ をメビウス変換というようです。
		</p>
		<p>
			ゼータ変換とは簡単に何かというと、幅 $2$ の $n$ 次元の累積和を求めることなのだと解釈しました。
			$S$ という集合があり、これの部分集合のすべての和を求めるということなので、たしかにそうなっていそうです。
		</p>
		<p>
			メビウス変換は、累積和からもとの値を求めるものというふうに考えていいかも知れません。差分を求めるので他にも使えそうだけど。
		</p>
		<p>
			ここでメビウス変換の式を見ると包除原理が使われているようです。これは $2$ 次元累積和から値を求めるときを考えてみるとわかりやすいです。
			二次元累積和から値を求めるときは、 $sum[i][j] - (sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1])$ とやりますが、
			この時、$sum[i-1][j] + sum[i][j-1]$ をやると、$sum[i-1][j-1]$ の部分についてダブっているので、これを解消するために $sum[i-1][j-1]$ を引くわけです。
			ということを考えると、思いっきり包除原理が使われています。そのためこれを一般化すると、さっきの $g$ がでてくるわけです。
		</p>
		<h2>高速ゼータ変換・高速メビウス変換</h2>
		<p>
			しかし、式のままだと、すべての集合について求めたい時高速に求まらないので、
			それを速くやりたいということになります。そしてこれが $O(2^N N)$ でできるようです。
		</p>
		<p>
			とりあえず高速ゼータ変換についてですが、これも累積和であることを意識するとかなり理解しやすくなります。
			$2$ 次元累積和を求める時、左から右に一気に求めて、そのあと、上から下へ一気に求めるとすべて求まることがわかります。
			この形だと特に重複無しで次元ごとに分けて計算ができるのでそのまま $n$ 次元に適用できます。
		</p>
		</p>
			つまり、各次元について、$S$ をすべて見て、$S$ についてその次元の $idx$ が $1$ である場合(つまり $idx$ が $S$ に含まれている時) 
			$0$ であるものの要素を足し上げるということをします。
			このようにすると、重複無しで $n$ 次元の累積和が求まることがわかります。
		</p>
		<p>
			高速メビウス変換は、これと同じ要領でできて、同じように各次元について見て、$S$ についてその次元の idx が $1$ である場合に $0$ であるものを引けばいいです。
			高速ゼータ変換も高速メビウス変換も次元についてのループが外側で回るようにします。
		</p>
		<h2>感想</h2>
		<p>
			けっこうとっかかりづらかったのですが、実際に勉強してみると、そういうことだったのかとなった。
			自分は数式が苦手なので、こういうふうに言葉で書いたり感覚的に理解したりできると嬉しいと思う反面、
			もっと深く理解したいなと思うと厳密にやるために数学が必要になるよなぁと思っています。
		</p>
		<p>
			彩色数もそうだけど、ある集合きっちりになるものの値が求まりづらいから、
			部分集合も含めていいという条件で解いておいて、それを後でメビウス変換するという流れになるのかな。
		</p>
		<h2>参考になったサイト</h2>
		<ul>
			<li><a href="https://qiita.com/convexineq/items/afc84dfb9ee4ec4a67d5">「ゼータ変換・メビウス変換を理解する」 @convexineq 氏 Qiita</a></li>
			<li><a href="https://qiita.com/Euglenese/items/260f9ddf513f772d7e42">「高速ゼータ変換について」 @Euglenese 氏 Qiita</a></li>
			<li><a href="https://www.slideshare.net/wata_orz/ss-12131479">「指数時間アルゴリズム入門」 Yoichi Iwata 氏 slideshare</a></li>
		</ul>
		(2023/11/13 22:01)
        <hr>
		<a href="index.html"> 目次に戻る </a>
	</body>
</html>
