<!DOCTYPE html>
<html>
    <head>
        <title>tinumuのホームページ</title>
        <link rel=stylesheet type="text/css" href="../style.css">
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
		</script>
		<script type="text/javascript"
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
		</script>
		<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
    </head>
    <body>
		<h1>水DiffからSolver順に解く　ひとことコメント#4 #000301-#000400</h1>
		<a href="index.html"> 目次に戻る </a>
		<h2>概要</h2>
		<p>
			<a href="https://kenkoooo.com/atcoder/#/list/tinumukiti631?rated=Only+Rated&status=All&fromDiff=1200&toDiff=1000000000000000000&sortBy=solverCount&sortOrder=desc">AtCoder Problemsのリンク</a>
		</p>
        <p>
			今回も 100 問解き、合計 400 問解けました。
			今回の問題の傾向は 青 Diff の ABC 問題てんこ盛りという感じでしょうか。新しい ABC でもかなり増えてきた感じがある。
			あと AGC の青の問題も結構多い。あと ARC の水色がちょこちょこ出た感じだった。
			基本的に ABC の水色に毛が生えたくらいの難易度が多く、実装難だったりするものがあるので Diff が高めなのかもしれない。
			でも少し難し目のアルゴリズムを要求する問題も増えてきた気がする。
			$O(3^N)$ のやつとか包除原理を使うやつとか、高速ゼータ変換を使うやつとか、並列二分探索を使うやつとか。
			半分全列挙も少しテクニカルだと Diff が上がる。あと bitset 高速化とかもある。
			あと難しい基盤で水色とかで使われるアルゴリズムを利用したりとか、まあ色々ある。
			まあ ABC については実装が重いのが多かったような感じがする。
		</p>
		<p>
			今回は 100 問自力 AC です。今回はちゃんと通るだろう解法ですべて通せたのでよかった。
			その上で様々な解法に触れられたのでかなり力になったと思う。
			データ構造も使えるものが結構増えた。
		</p>
		<p>
			そんなこんなで、11/07 から 12/10 までこの100問を解いたわけです。
			どんどん解くのが遅くなっているが、やっぱり書くのとの並行作業になると書く量も増えているしこのくらいかかっちゃうようだ。
		</p>
		<p>
			Solver が 2515 人から 2050 人までの問題でした。
		</p>
		<h2>#000301 Bracket Sequencing</h2>
		<p>
			既に括弧列になっている部分文字列については特に考慮する必要もないのでこれらをすべて消してみる。
			すると、"))...)((...(" というような文字列だけが残ることがわかる。
			仮に $i$ の ')' の数を $L[i]$ , '(' の数を $R[i]$ とすると、
			$R[i]-L[i] \geq 0$ のものについて $L[i]$ の小さい順に
			左から並べていくと最も途中で ')' が '(' の数を超えにくい構造になっている。
			$R[i]-L[i] &lt 0$ のものについては、 $R[i]$ の小さい順に
			右から並べていくと良い。
			これをつなげたときに括弧列が完成するならば "Yes" という感じだ。
		</p>
		<h2>#000302 Find Symmetries</h2>
		<p>
			$A, B$ を選んだときの答えと $(A+1) \bmod N, (B+1) \bmod N$ を選んだときの答えが実は同じになる。
			比較する部分の要素に全く変化がないからである。
			したがって、$A=0$ と固定して、$0 \leq B &lt N$ である $B$ について調べればよく、
			これは $O(N^3)$ で数えることができる。
		</p>
		<p>
			これを考えなくても一応差分を利用して問題を解くことができるが変に実装が長くなる。
		</p>
		<h2>#000303 Sky Reflector</h2>
		<p>
			まず $N=1$ のときは $K^M$ が答えであり、$M=1$ のときは $K^N$ が答えになる。
			これを除いて $N, M \geq 2$ のときについて考える。
		</p>
		<p>
			$B$ の最小値 $b$ について考えてみる。$b$ が最小値になるような 
			$B$ のパターンは $(K-b+1)^M - (K-b)^M$ 通りある。
			また $b$ が決まっていると、$A$ の値というのは $b$ 以下の任意の値ということになる。
			そのため $A$ のパターンは $b^N$ 通りあると言え、答えは、
			$$ \displaystyle \sum_{b=1}^{K} b^N \times ((K-b+1)^M - (K-b)^M) $$
			ということになる。
		</p>
		<p>
			$B$ のパターンの数についてすぐにでてくると嬉しい。$b$ よりも大きい $B$ の最小値になるものを
			引けばいいということがすぐにわからなくて手こずった。
		</p>
		<h2>#000304 Integer Product</h2>
		<p>
			まずすべての値を $10^9$ 倍しておく。この時、積が整数になるという条件は、$10^{18}$ で割り切れることと同値である。
			これをもっと突き詰めて考えると、整数が $2$ で何回割り切れるか, $5$ で何回割り切れるかという情報だけ持っておけば
			良いことがわかる。これを $i, j$ で足したときに どちらも $18$ 回以上割り切れるならば良いという感じである。
		</p>
		<p>
			$A[i] \times 10^9$ が $2$ で割り切れる数を $X[i]$ , $5$ で割り切れる数を $Y[i]$ とすると、
			$X[i]$ の小さい方から見て、$X[i] + X[j] \leq 18$ であるような $j$ について、
			$Y[j]$ の数を足し上げていく。cnt[Y[j]]++ のようなことをする。
			すると、$18-X[i]$ 以上の $Y$ についてはすべて $i$ について条件を満たすことがわかるので、
			その数を足し上げる。
		</p>
		<p>
			なお、これだと $i &lt j$ ではないが、同じものを取り除く処理をした後答えを $1/2$ したらその答えが出てくる。
		</p>
		<h2>#000305 Odd or Even</h2>
		<p>
			まず、$A_1, A_2, \cdots, A_K, A_{K+1}$ について、この中のある一つの要素を使わないようにするような
			感じで、それぞれ聞いていく( $K+1$ 回)。
			すると、それらの総和が、 $K(A_1 + A_2 + \cdots + A_{K+1})$ となっており、この答え $S$ が求まっているはずである。
			今回は偶奇だけが重要であるので、$K$ が奇数より、 
			$A_1 + A_2 + \cdots + A_{K+1}$ の総和の偶奇が求まったことになる。
			すると、先程各要素を使わない答えを求めていたので、例えば $A_1 + A_2 + \cdots + A_K$ の答えとの比較をすると、
			$A_{K+1}$ の答えを知ることができる。あとは、それぞれ $A_i$ を使ってないときの答えと照らし合わせると、
			最終的に $A_1$ から $A_{K+1}$ の中身を知ることができる。
		</p>
		<p>
			あとは、右にスライドしていくと、次々と $A$ の中身を知ることができ、
			これら合わせて合計 $N$ 回ちょうどで行うことができる。
		</p>
		<h2>#000306 RGB Coloring</h2>
		<p>
			赤色を塗った後青色を塗ると緑色になるといった解釈をして考えていくと良い。
			すると、まず赤色を塗る個数を選び、それをもとに青色を何個塗らないといけないかがわかるので、
			それぞれの塗る個数を $r, b$ とすると、$ \binom{N}{r} \times \binom{N}{b}$ によって答えが求まる。
			これをすべての $j$ について見ていけば良い。
			もちろん $K-rA$ が $B$ で割り切れないとそもそも作れない。
		</p>
		<h2>#000307 Triple Shift</h2>
		<p>
			まず入っている値が一致しないといけないのでそうでない場合を取り除いておく。
		</p>
		<p>
			操作によって逆操作ができるので、$B$ も操作できる。
			つぎに $A$ の値が重複なしの場合を考える。この場合それぞれの操作で転倒数が $2$ ずつ変化する。
			そしてこの時転倒数を $0$ あるいは $1$ にすることが可能である。
			$A_{N-2}$ までソートしたときの、 $A_{N-1}$ と $A_N$ の大小関係がその転倒数 $0$ か $1$ かである。
			以上を考えると、$A$ と $B$ の転倒数の偶奇が一致しない場合はどうやっても不可能で、
			偶奇が一致する場合は $A, B$ ともに $A_{N-2}$, $B_{N-2}$ までソートしてあげると必ず一致している。
		</p>
		<p>
			同じ値がある場合はどうだろうか。このとき、同じ値同士を入れ替えると、
			転倒数の偶奇を変化させることができるはずだ。そしてこれが重要な本質であり、
			その同じ値の位置関係を保ったまま $A_{N-2}$ までソートできるので、転倒数を偶数にしてから
			ソートを行うと完全にソートができる。
			そのため、$A, B$ ともにソートして同じ値にすることができる。
		</p>
		<h2>#000308 Regular Triangle Inside a Rectangle</h2>
		<p>
			すべての正三角形はできるだけ大きくした後、
			正三角形のどこかの頂点を長方形のどこかの頂点へ平行移動させても
			同じように作れることがわかるので、どこかの頂点は共有することがわかる。
			またそのような頂点がどこかを固定しても同じ答えが出せるのでサンプルにあるような右上の頂点が共有すると
			仮定してしまって良い。
		</p>
		<p>
			この時ある長さ $L$ の正三角形を作ると仮定して作れるかどうかを判定する問題に帰着させて、二分探索しようと思う。
			この時、右上のところからは $2$ つの辺がでてくるわけだが、まず上の辺から考えてみる。
			観察すると、角度が大きくなればなるほど、$x$ 軸の長さが小さくなるので、その辺だけ考えるとある角度で
			収まる場所が見つかるわけである。なお $y$ が大きくなりすぎた場合は取り除いておくこと。
			同じように下の辺も考えると、 $y$ 軸の長さが長方形に収まるところが同じように見つかる。
			このとき出来上がった２辺の角度を見て、$60^\circ$ 以上あれば、どちらかの辺を角度が $60^\circ$ になるように調整すれば
			いいので、作れることがわかる。
		</p>
		<p>
			判定の仕方によっては誤差が大きくなってしまって WA が出る場合があるので注意。特に引き算は気をつける。
			角度を見つける場面でさらに二分探索を使うと安全だと思う。
		</p>
		<h2>#000309 Restore the Tree</h2>
		<p>
			入次数 $0$ の頂点を取り除いていくと、次に取り除く頂点が判明するときに現在の頂点が親になる。
			このようにしながら DFS していくと解ける。
		</p>
		<h2>#000310 At Least One</h2>
		<p>
			$S$ の左端の小さい方から見るとする。この時、右端を右にスライドすると、
			初めてすべての $i$ の値が入る位置がわかるはずである。そのためそれより右は作れることがわかる。
			つまりこの問題は尺取り法が使える。
			長さ $k$ 関連については、その位置が見つかれば最大の長さもわかるわけなので、それより小さいものもすべて含むように
			imos 法を使って答えを出せば良い。
		</p>
		<h2>#000311 Sum of Three Terms</h2>
		<p>
			$S_i = A_i + A_{i+1} + A_{i+2}$ であるので、
			$S_{i+1} - S_i = A_{i+3} - A_i$ であることがわかる。
			あと、 $A_3 = S_1 - A_2 - A_1$ であることを考えると、$A_1, A_2$ さえ決まればすべての項が決定することになる。
			このとき、 $A_1 = 0$ としてシミュレーションし、 $A_2 = 0$ としてシミュレーションしたときにそれぞれについて $A$ の最小値が出るはずである。
			このときそれがマイナスならば、$A_1$ や $A_2$ を調整することでマイナスにならないようにする下限の値が出るはずである。
			この値に $A_1$ と $A_2$ を調整し、あとは、 $A_3 = S_0 - A_1 - A_2$ と置いてシミュレーションしたときに、$A$ の値が $0$ 未満になっていないかどうかを見れば良い。
			なっていなければ "Yes" でその $A$ を出力。なっていたら "No" である。
			Diff = 1239 ...? 
		</p>
		<h2>#000312 Sorting Color Balls</h2>
		<p>
			結局の所 $X$ を並び替えるときにはバブルソートのようになるので、並べ替え方は変わらないはずである。
			それを考えると、色を度外視したときの転倒数から、それぞれの色についての転倒数を引いていけば答えが出そうである。
			入れ替えるべきペアのコストが同じ色同士ならかからないと考えると、それはちょうどその色の転倒数の和になっているはずである。
		</p>
		<p>
			そのため、それぞれの色に対して転倒数を求めればいいが、座圧をして計算量を下げる必要があるのでそこに注意する。
		</p>
		<h2>#000313 Pay to Win</h2>
		<p>
			#000261「+1-1x2」 でやったように、逆操作を考えたい。
			すると、同じように、近傍の $2$ の倍数の位置, $3$ の倍数の位置、$5$ の倍数の位置しか考えなくていいことがわかる。
			すると、状態数はあまり多くなく、DP が可能になる。
			ただ、値を減らすときに (操作回数) $\times D$ が 64bit 整数を余裕でオーバーフローするのでそこに気をつける。
		</p>
		<h2>#000314 Potion</h2>
		<p>
			$k$ 種類の素材を合成することを考えると、組み合わせたポーションの魔力を $k$ で割ったあまりと、
			$X$ を $k$ で割ったあまりが一致していれば魔力 $X$ のポーションを作れることがわかる。
			したがって、各 $k$ ごとに、$\mathrm{dp}[i][j][m]$ ... 素材 $i$ まで見たとき、 $j$ 個組み合わせていて、
			合計を割ったあまりが $m$ であるようなポーションの合成の仕方の最大値、という DP をすれば良い。
		</p>
		<p>
			これで答えは $\mathrm{dp}[N][k][X \bmod k]$ に出てくる。
			計算量はこの DP を $N$ 回行うので、$O(N^4)$ である。
			$k$ が小さいと DP の計算も少し小さくなるのでちゃんと間に合う。
		</p>
		<h2>#000315 Complete Binary Tree</h2>
		<p>
			ABC321 の感想で書いてある。
		</p>
		<p>
			$f(x, k)$ ... $x$ の部分木について深さが $k$ であるようなものの個数
			といったような物を考えて、これを $X$ を親に遡るような形で解いていく。
			なお、それぞれがダブらないように実際には $X$ の祖先の計算していない方の子について $f$ を求める。
		</p>
		<p>
			$f$ の計算は $O(1)$ で求まるので、全体で $O(\log N)$ で解ける。
			めんどくさい場合 $f$ に $O(\log N)$ かけて $O(\log^2 N)$ で解くこともある。
		</p>
		<h2>#000316 Enclose All</h2>
		<p>
			円をとても大きい状態から小さくするときに当たる頂点について考えると、
			$2$ 点のみであるか、 $3$ 点以上ということになる。しかし円は $3$ 点与えられると円の形が完全に
			決まってしまうことから、$4$ 点以上のものについて全探索する必要はない。
			また、$2$ 点を定めて探索するときにその $2$ 点を包含するために最小の円を考えるときに
			他の点が包含できない場合 $3$ 点の方で答えが探されているので、
			今回は $2$ 点決めたときの最小の円と、$3$ 点決めたときの最小の円について全探索すれば良い。
			この時、外心を求める必要があるが、これが難しいが逆に言えばこれさえ求められれば解ける。
		</p>
		<p>
			こんな解法を使わずとも、二分探索が思いつけば解ける。
			円の半径 $r$ を先に決めてしまうと、点たちについて点を中心とする半径 $r$ の円を考え、
			それぞれの交点を中心とした半径 $r$ の円がすべてを包含するかを見れば良い。
			交点以外の場所で包含できる時、交点で包含できるところが必ず見つかる為これが成り立つ。
			幾何ライブラリを整備しておくとよい。
		</p>
		<h2>#000317 Range Add Query</h2>
		<p>
			自分は $X$ の数列に対して $B$ という数列を考えて、$B_i$ ... $X$ を左から $0$ にしていくときに
			$i$ 番目に減算しなければならない値というものを考えた。
			$X$ の長さを $n$ とすると、 $B_{n-K+1} = ... =  B_{n} = 0$ であれば良い数列ということになる。
			実験していくと、$B_i = X_i - X_{i-1} + B_{i-K}(i \leq 2) , B_1 = A_1$ であることがわかるので、
			$X$ の階差の累積和を持ってそれぞれ $B_{n-K+1} ... B_n$ について計算すれば
			$O(K)$ で計算できることがわかる。
		</p>
		<p>
			これを実際の $A$ に対して $B_l = A_l$ であることに気をつけながら $B_{r-K+1} ... B_r$ に対して
			計算すると、$O(K)$ で判定できるので $O(QK)$ で求まる。
		</p>
		<p>
			想定解では階差数列について考えることで、その階差の $K$ 個飛ばし( $K-1$ 個飛ばしとも言う？) についての総和が
			$0$ であることを確かめる解法になっている。こっちのほうが自然に導出できるので考えるときはそっちのほうが良い。
			やっていることは同じになると思う。
		</p>
		<p>
			単純な累積和じゃないので境界について処理しなければならずインデックスの管理も難しいので
			かなりやりづらい問題になっていると思う。考察の段階も考えると D 問題なんだろうか・・・
		</p>
		<h2>#000318 Cards</h2>
		<p>
			数を頂点として、カードを辺と考えると、このグラフは連結成分が何個かある閉路でできたグラフになる。
			つまり円環上になっている。
			この時どの数もカードのいずれかに書かれている状態というのは、辺が最初白で塗られていて、
			辺を黒で塗るものをカードを選ぶとしたときに白が連続して塗られているようなところがないような塗り方
			ということになる。これはリュカ数という数で表すことができ、各連結成分ごとにリュカ数をかけ合わせれば
			答えが出ることになる。リュカ数を知らなくても予め dp を考えておけば普通に解ける。
		</p>
		<h2>#000319 LRUD Game</h2>
		<p>
			嘘貪欲が通る問題。高橋くんができるだけある方向に落としたいときに青木くんが防げるかみたいな問題を
			解くと、青木くんが逆の方向にずっと進めば良いみたいな感じだが、その逆に進むときに
			逆に高橋くんが逆の方向で落とせる可能性がでてくるので正しくない答えになる。
		</p>
		<p>
			この問題は、ゲームの問題でよくあるように、最後の状態から考えて、行ってしまうと確実に落とされるマス
			というのを考える必要がある。この時、途中ですべてのマスがいけなくなったらどうやっても高橋くんが勝ち、
			最終的にマスは残るが、そもそも駒がそのマスにない場合は高橋くんの勝ち、
			逆にそうでない場合は、常に行ってはいけないマスに行かないように青木くんが行動できるので、
			青木くんが勝つことができる。
			これをきちんと書くことでちゃんとした答えになる。
		</p>
		<h2>#000320 Integers on Grid</h2>
		<p>
			DP を解くような形になっているが、例によって辺の数が多いのでこれを下げる必要がある。
			$\mathrm{dp}[i]$ ... $(r_i, c_i)$ にいるときに移動できる回数という DP を考えるが、
			これを解くには、$a_i$ より大きい値の DP の値が求まっているとき、その中で持ってきたい値というのは、
			同じ列あるいは同じ行の値の最大値になる。
			これは $\mathrm{rowmax}[r]$ , $\mathrm{colmax}[c]$ みたいにしてそれぞれ行における最大値と
			列における最大値を持ち、 DP 中に更新しながらやっていけば $\mathrm{dp}[i]$ について $O(1)$ で求まることがわかる。
		</p>
		<p>
			具体的な実装方法は、まず $a_i$ の大きい順に $\mathrm{dp}[i]$ を決定することを考える。
			$a_i$ が同じものを同率に処理することで、$\mathrm{rowmax}, \mathrm{colmax}$ は常に値が $a_i+1$ 以上の
			DP 配列についての最大値が入っていることになる。同じ物の DP 配列を処理したら、
			そのアクセスした DP 配列たちについて $\mathrm{rowmax}[r_i], \mathrm{colmax}[c_i]$ を更新すれば
			一つの $i$ について $O(1)$ で処理できるので、処理は $O(N)$ でできることがわかる。
		</p>
		<p>
			ソートに時間がかかるので $O(N \log N + H + W)$ かなぁ。
		</p>
		<p>
			いろいろな実装方法があるが、最も簡潔な実装方法で持って実装し始めるのは難しいと思う。
			今回は DP をまとめることで遷移を減らすというよくあるテクニックだが少し高度だと思う。
			まとめ方を工夫するという方法も覚えていきたい。
		</p>
		<h2>#000321 Voting Judges</h2>
		<p>
			#000174 Project Planning とやり方がかなりかぶる問題。と言うかこっちのほうが難しい？なんで水 Diff なのか。
			まず、明らかなのは、$A_i$ が大きいほど採用されるということである。よって二分探索が使える。
			適当に降順ソートしておくとよい。とりあえず $A$ が降順ソートされていることを前提に考える。
		</p>
		<p>
			そのため今考えたいのは、 $i$ が採用されるのかということである。 
			$1 \leq i \leq P$ の $i$ は必ず採用されるのでこれらは省いておく。
			まず、$i$ には $M$ 人が投票するというのは間違いないだろう。
			このとき、$A_i + M$ より大きいスコアのものが $P$ 個以上あるようなら不可能である。
			そうでない時のことを考える。
			まず、問題が採用されさえすればいいので、スコアの大きい $P-1$ 問はできるだけ投票してしまっても良い。
			このとき残っているのは $A_i + M$ より小さいスコアのものについてである。
			これらに対して $V-P$ 問 $M$ 人が選ぶ時、$A_i + M$ を超えないように投票する方法について考える。
			簡単のため $V-P = v, A_i + M = L$ と置いておく。
			これは、#000174 Project Planning のように、各問題について $1$ から $M$ まで回すように入れていくと、
			できるだけ入れることができることがわかるので、$\sum_{j} \min{(L-A_j, M)} \geq vM$ であれば
			そのような条件で入れることができることがわかる。
		</p>
		<p>
			ということから、この問題は $O(N \log N)$ で解ける。
			変に説明が難しくなった。
		</p>
		<h2>#000322 Saving Snuuk</h2>
		<p>
			ある両替所まで円で行き、ある両替所からはスヌークで行くので、$s$ から両替所までの円の最短経路を求めておき、
			$t$ から両替所までのスヌークの最短経路を求めておけば各 $i$ にその両替所を使ったときの答えがでている。
			あとは、 都市 $n$ から $1$ へ累積 max を求めておけば残りのスヌークの最大額が出る。
		</p>
		<h2>#000323 Digit Sum Replace</h2>
		<p>
			この問題は実は連続する $2$ 桁をどのように選んでも最終的に開催する回数は変わらない。
			桁和に着目すると、ある $2$ 桁を選んだときに繰り上がりが起こらない場合桁和は変わらず、
			繰り上がりが起こる場合は桁和は $9$ 減ることになる。
			開催する回数はこの繰り上がりの回数だけ増えることになり、結局のところ最終的に桁和は $1$ から $9$ の
			どれかになるので、増える回数は最初の桁和を $s$ とすると、 $ \left\lfloor (s-1)/9 \right\rfloor$ 回となり、
			操作の位置によらないことがわかる。
		</p>
		<p>
			そのため答えは、
			$\displaystyle \left( \sum_{i=1}^M c_i \right) - 1 + \left\lfloor \frac{\left(\sum_{i=1}^M c_i \times d_i \right)-1}{9} \right\rfloor$
			となる。
		</p>
		<h2>以下テンプレート</h2>
		<h2>まとめてみる</h2>
		<h2>重要な問題を並べる</h2>
		<h3>重要</h3>
		<h3>準重要</h3>
		<h2>感想</h2>
		(2024/01/01 03:06)
        <hr>
		<a href="index.html"> 目次に戻る </a>
	</body>
</html>
