<!DOCTYPE html>
<html>
    <head>
        <title>tinumuのホームページ</title>
        <link rel=stylesheet type="text/css" href="../style.css">
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
		</script>
		<script type="text/javascript"
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
		</script>
		<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
    </head>
    <body>
		<h1>AGC002 D - Stamp Rally</h1>
		<a href="index.html"> 目次に戻る </a>
		<h2>概要</h2>
		<p>
			<a href="https://atcoder.jp/contests/agc002/tasks/agc002_d">問題のリンク</a>
		</p>
		<p>
			いろいろな解き方があり、面白い。この問題を要約すると、$x$ と $y$ の連結成分のサイズの和
			($x$ と $y$ が連結なときは $x$ 成分のみのサイズだけ見る) が $z$ 以上になるような
			スコアの最小値はどこかという問題である。
		</p>
		<p>
			たとえば、一つのクエリについてあるスコアを超えればすべて $z$ 以上になるので、スコアで二分探索ができる。
			しかし、あるスコアについて見る時、そこまでの頂点を連結させる処理が必要になるので一回の計算ごとに
			$O(M)$ くらいかかってしまう(アッカーマンの逆関数については省く)。
			そうすると、 $O(QM \log M)$ 程度かかってしまう。
		</p>
		<p>
			そこで様々な工夫をすることで計算を早く行いたい。
		</p>
		<h2>実装方法 1</h2>
		<p>
			まず１つの方針として、ある時系列の連結成分の情報について高速に取り出せるようにするという方法がある。
		</p>

		<h3>最初に通したときの実装(連結を表現した木を作る)</h3>
		<p>
			自分が最初に実装した方法だと、ある時刻 $t$ に起こった連結を保存する木(頂点数 $2 \times N-1$ )を生成し、
			時刻 $t$ 以下に連結された部分木の中で、頂点 $x$ を含むような極大の部分木を高速に探す方法である。
			そしてその部分木の葉の個数(実際の頂点はすべて葉であるため)を取れるようにしておけば、
			$x$ がある $t$ のときの連結された成分の個数を高速に取れるというわけである。
		</p>
		<p>
			これを実装するためには、そのような木のエッジに時刻の経過を意味するコストを入れて、根付き木を生成すると良い。
			このとき、ダブリング辺にまとめた辺のコストの和を入れるようにすれば、葉からある祖先までたどったときに
			どの程度の時間が経過したのかがわかるので、それが $t$ 以下ならば進み、そうでないなら進まないというようにすることで
			時刻 $t$ 以下の頂点 $x$ を含むような極大の部分木が $O(\log N)$ で見つけられる。
			これで、クエリに対して二分探索と極大の部分木を探す計算量がかかるので、
			$O(Q \log M \log N)$ で計算できる。
		</p>
		<p>
			ちょっと重い。少なくとも 674ms 程度はかかるようだ。
		</p>
		<h3>部分永続 Union-Find を使用した解法</h3>
		<p>
			この Union-Find は時系列データに対して使えるようである。何ができるかと言うと時刻 $t$ における連結情報を
			保存しているのでそのときに何が連結しているかと、その時の連結成分の大きさを返せるというものである。
			まさにこの問題で必要とされていることである。
		</p>
		<p>
			普通の永続 Union-Find はおそらく時系列に対して 1 方向ではなく、木のように分岐させても状態を保存できるのかな？
			ちょっとあまり調べてないのでわからないが、まあこの問題には 1 方向で十分である。
		</p>
		<p>
			普通の Union-Find と違って経路圧縮ができないので各クエリの計算量が $O(\alpha(N))$ ではなくなってしまうが、
			Union by rank か Union by size のつなぎ方をやっておけば、 $O(\log N)$ ですむので十分速いだろう。
		</p>
		<p>
			実装方法は、親に連結された時間 $T_u$ を保存するのと、あるノードのある時刻における連結成分の大きさを保存することで、
			ある時刻 $t$ のルートを見つけたいときは $T_u \leq t$ であるまで遡ればいいということがわかる。
			また、サイズを知りたいときはまず $u$ のルート $r$ を見つけてから $r$ の連結成分の大きさについてのリストについて
			二分探索すればある時刻までの連結成分の大きさを見つけられるといった感じである。
		</p>
		<p>
			よってこの方法でも、クエリについて $O(Q \log M \log N)$ で調べられる。
			こっちは $2$ 倍のノードを生成する必要もなくダブリングもする必要もないので定数倍が軽く、
			228ms 程度で通る。
		</p>
		<h2>実装方法 2 (想定解)</h2>
		<p>
			並列二分探索という、すべてのクエリに対して二分探索を $1$ 回進めてしまうという方法が想定解である。
			今回は、連結情報を取るためにクエリごとに逐一 Union-Find を $O(M)$ 回回す必要があったが、
			この連結させている最中に $Q$ 個のクエリを処理してしまおうというアイデアである。
		</p>
		<p>
			二分探索の ok と ng という値をクエリごと( $ok_j, ng_j$ みたいに) に持っておく。
			そして現在調べたいスコアというのは $(ok_j + ng_j) / 2$ であるので、
			それぞれの調べたいスコアの位置にクエリを入れておくことにする。
		</p>
		<p>
			すると、グラフを連結させた適切なタイミングでクエリがでてくるので、その時の $x_j$ と $y_j$ のサイズについて
			見るだけで済み、このときに すべての $j$ における二分探索を一つ進めることができる。
		</p>
		<p>
			つまりこの連結させる処理を $O(\log M)$ 回程度行えば、すべての二分探索を終えることができる。
			この計算量は $O((Q+M+N)\log M)$ 程度であり一番高速だと思う(アッカーマンの逆関数は除く)。
			通してみたら 108 ms 程度だったのでこの３つの中では一番速いと思う。
		</p>
		<p>
			データ構造も普通の Union-Find しか使わないので最もイージーな実装方法になっている。
		</p>
		<h2>ソースコード</h2>
		<h3>最初に通したときの実装</h3>
		<script src="https://gist.github.com/tinumu/ef6472eef3a7caeca90313b263805068.js"></script>
		<p>
			Union-Find の実装やその他の非本質の部分は省く。
		</p>
		<p>
			前に書いた <a href="RootedTree.html">根付き木のライブラリを書いてみたよ</a> の根付き木のライブラリに
			多少関数を追加している(getAncestor, getAncestorDist)。
			RootedTree のエッジを張ったら部分木について葉の数を計算しておき、
			クエリ処理するという流れである。
		</p>
		<h3>部分永続 Union-Find を使用した実装</h3>
		<script src="https://gist.github.com/tinumu/9d19ed2da8b6e734ad48ef9d515112ac.js"></script>
		<p>
			こっちは割とこじんまりとしている。$t$ は昇順に入れる必要がある。
		</p>
		<h3>想定解 並列二分探索</h3>
		<script src="https://gist.github.com/tinumu/d71927cbc7d6923338da111f3e8e6ed6.js"></script>
		<p>
			クエリの処理の方法の工夫。
		</p>
		<h2>感想</h2>
		<p>
			並列二分探索などは、かなり使い勝手がいいと思った。ただ、クエリ内で二分探索する系って多いのかな？
			だけれども、色々と知れるのはやはり嬉しい。1000 点問題で橙 Diff であるが、思いつきやすい問題ではあったと思う。
			ただデータ構造を知らないで普通に実装しようとするとかなり難しいなと思う。
			逆にデータ構造さえ知っていれば貼ればいいみたいな状態ではあったので結構知識ゲーなのかなとも思った。
		</p>
		<h2>参考になったサイト</h2>
		<ul>
			<li><a href="https://www.mathenachia.blog/agc002d-usereditorial/"> AGC002 - D ユーザ解説 Nachia 氏</a></li>
			<li><a href="https://blog.tiramister.net/posts/persistent-unionfind/"> 部分永続 UnionFind の実装 Tiramister 氏</a></li>
		</ul>
		(2023/11/24 22:24)
        <hr>
		<a href="index.html"> 目次に戻る </a>
	</body>
</html>
