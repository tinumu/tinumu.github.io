<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="../mainstyle.css">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script type="text/javascript"
src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
inlineMath: [['$','$'], ['\\(','\\)']],
processEscapes: true
},
CommonHTML: { matchFontHeight: false }
});
</script>

<title>Diary</title>
</head>
<body>
<h1>JOI2008-2009春合宿1-3 Pyramid(貫きピラミッド)</h1>
<h2>概要</h2>
<p>
<a href="https://www.ioi-jp.org/camp/2009/2009-sp-tasks/2009-sp_tr-day1_20.pdf">これ。</a><br>
東西幅 $W$ , 南北幅 $H$ の長方形の砂漠がある。<br>
ピラミッドがそこに複数つくられる。<br>
区画 $(X, Y)$ を中心とした高さ $h$ のピラミッドがその中に作られるとすると、<br>
砂漠内の区画 $(x, y)$ にいるとき、そこには $max$ { $0, h - max$ { $|X - x|, |Y - y|$ } }  個の石を積む必要がある。<br>
もしもピラミッドが重複するときにある位置に $n$ 個積み上げなければならないときは、<br>
そこに $n$ 個以上あるならば何もせず、$n$ 個未満ならば $n$ 個まで積み上げる。<br>
こうして、それぞれのピラミッドの座標 $x_i, y_i$ と高さ $h_i$ が与えられたときに、石は合計何個積み上げるかという問題。
</p>
<h2>制約</h2>
<ul>
<li>$1 \leq H, W \leq 3000$</li>
<li>$1 \leq N \leq 10000$</li>
<li>$0 \leq x_i \lt W$</li>
<li>$0 \leq y_i \lt H$</li>
<li>$1 \leq h_i \leq 3000$</li>
</ul>
<h2>解法</h2>
<p>
どうにかして、それぞれのピラミッドを全体へ遷移させなければならないが、<br>
それぞれのピラミッドずつ、処理を行っていくと、 $O(NHW)$ となってしまい、無謀である。<br>
計算量を減らす方法として、様々な方法を考える必要があるが、<br>
ここでは、ピラミッドの中心の数 $N$ について考えず、マップ一体として考えることが出来るのではないかということを考える。<br>
このような着想に至る理由としては、マップ内に目的物が $N$ 個含まれるような形になっているということは、<br>
マップ全体に対する処理を行うことで、目的物すべてに対する処理を一気に行えるのではないかという考えがあったからだ。<br>
<br>
ということで、よく考える。<br>
<br>
ピラミッドの中心から遠くなるある方向に $1$ マスズラした位置の石段の高さは $1$ だけ下がることが分かる。<br>
ピラミッドの中心の高さを、指定した座標に置き、そのある方向に連続的に $-1$ しながら遷移させていけば、<br>
すべてのピラミッドの中心からそのある方向に伸ばしたマップの状態が出来上がる。 $O(HW)$<br>
もしも重複するならば、定義通り大きいものを選択すればよい(DPの要領で行うとよい)。<br>
<br>
さて、実際にはピラミッドの形にしなければならない。<br>
実は、一つのピラミッドにおいて、ある部分の高さが一番大きくなるような遷移の仕方は、<br>
隣り合った二つの方向を使っていることが分かる。<br>
よって、以前ある方向に伸ばしたマップを利用して違う方向に遷移させればよいということがわかる。<br>
8方向に対してマップを使いまわして同じ処理を行っていけば、最終的に定義通りに伸ばせる。 $O(HW)$ <br>
<br>
また、そのやり方だと、ピラミッドの中心の方向へ伸ばしたらまずいのではないかって思うが、<br>
これについては、定義で重複で大きいほうを選択するというようになっているので、 $-1$ して伸ばしても、<br>
選択されることはない。よって、中心へ伸ばす処理は支障がないことが分かる。<br>
<br>
実装方法としては、<br>
まずピラミッドの中心を座標にぶち込んでおいて、<br>
for(int i = 1; i &lt= H; i++) for(int j = 1; j &lt= W; j++) みたいにすると、右, 右下, 下, 左下に処理ができて、<br>
for(int i = H; i &gt 0; i--) for(int j = W; j &gt 0; j--) みたいにすると、左, 左上, 上, 右上に処理ができる。<br>
そのため、2回for文することでどうにかすることが出来る(伸ばしたときに選択するDPみたいなことをする)。<br>
あとは石の数を数えるために、数えていって終わり。
</p>
<h2>ソース</h2>
<script src="https://gist.github.com/tinumu/7a69f791320618ce2dc4af8ddff4c678.js"></script>
<h2>感想</h2>
<p>
思い浮かぶのは速かったけど、ちゃんと考察するのには時間がかかった。<br>
知見としては、<br>
<h3>・マップ内に目的物が $N$ 個だけ含まれている時は、マップ全体の処理を行うことで $N$ 個すべて処理出来る場合がある</h3>
とかかなぁ。<br>
ノードに着目するのか、マップに着目するのかというところは問題によっても異なるところだと思うからそこも見極めていきたいね。
</p>
</body>
</html>
