<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="../mainstyle.css">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script type="text/javascript"
src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
inlineMath: [['$','$'], ['\\(','\\)']],
processEscapes: true
},
CommonHTML: { matchFontHeight: false }
});
</script>

<title>Diary</title>
</head>
<body>
<h1>AGC020 参加記録</h1>
<h2>あいさつ</h2>
<p>
AGC020に参加しました。最高パフォーマンス2188が出せました。<br>
とはいえ、Cが解けなかったことは残念でしたね。<br>
今回は問題の記憶を明確に残すために参加記録として日記に記したいと思います。<br>
</p>
<h2>A - Move and Win　</h2>
<p>
<a href="https://agc020.contest.atcoder.jp/tasks/agc020_a">これ</a><br>
前提として、アリスはボリスを押し込めば勝ち、ボリスはアリスを押し込めば勝ちということになる。<br>
2人が隣接しているときに手番となっているほうは、自分から見て不利な方向にしか移動できなくなる。<br>
その後、相手が押し込んでいって負けとなってしまう。<br>
自分の手番が来るとき、必ず距離の偶奇は保たれるため、最初の距離の偶奇が試合の結果を左右することになる。<br>
距離 $B - A$ が偶数の時、隣接するときはボリスの手番であるので、アリスが勝ち、奇数の時は隣接時アリスの手番より、ボリスが勝つ。<br>
<script src="https://gist.github.com/tinumu/fbea87faf2676e04c1ccad2168aaa169.js"></script>
こういう形の問題は発想を思いつくのが難しいので、たくさん書いて小さいテストケースを試してみるといいかもしれない。
</p>
<h2>B - Ice Rink Game　</h2>
<a href="https://agc020.contest.atcoder.jp/tasks/agc020_b">これ</a><br>
最後に必ず2人残るということが決まっているため、そこから考えていく。<br>
$i(1 \leq i \leq K)$ 番目のゲームが終わったときの最少人数を $L_i$ , 最多を $R_i$ とする。<br>
このとき、何もゲームが始まっていない $L_0$ , $R_0$ を求めることが目的である。<br>
実は、$L_i$ , $R_i$ の値を使用して、 $L_{i - 1}$ , $R_{i - 1}$ の値を求めることが可能である。<br>
<pre>4
3 4 3 2</pre>
このテストケースを考えてみる。<br>
定義より $L_4 = R_4 = 2$ である。<br>
$A_4 = 2$ より、$3$ 人のグループと $2$ 人のグループであれば $2$ 人になってくれるということが分かる。<br>
つまり、$L_3 = 2, R_3 = 3$ であることが分かった。<br>
次に、$A_3 = 3$ であるが、残る人数は必ず $3$ の倍数になることが分かるので、現在最小である $2$ を捨て、$3$ になったときについて考えるようになる。<br>
そうすると、$L_2 = 3, R_2 = 5$ というようになる。<br>
これを一般的にすると、$L_{i - 1} = \frac{L_i + A_i - 1}{A_i} \times A_i$, $R_{i - 1} = \frac{R_i}{A_i} \times A_i + A_i - 1$ ということになる。<br>
$L$ と $R$ の中の値であれば必ず、最終的に2人になる。 $L$ から$R$ まで必ず連続して二人になることが保たれていなければならない。<br>
例えば $L_k = 2, R_k = 7$ で、$A_k = 3$ だった時に計算をする場合、実際は3, 6 人になる(3の倍数であり得る数)ことが分かるが、<br>
3, 6人になるには 3, 4, 5, 6, 7, 8人の場合があり得、3人になる3,4,5人と、6人になる6,7,8とで、連続を保つことが出来る。
求めていくと $L_0$ , $R_0$ が求まる。
また、$L \gt R$ になってしまったり、$A$ の倍数で出来るものがなかったりする場合において、どの値でも最終的に $2$ にはならないので、$-1$ を出力する。<br>
<script src="https://gist.github.com/tinumu/b65c2b94b135ad8e0e4be879ce461978.js"></script>
うまく解説ができない。基底条件となりそうな値を見つけて、そこからどうやって大きくしていくかという観点は重要であると感じた。
<h2> C - Median Sum　</h2>
<a href="https://agc020.contest.atcoder.jp/tasks/agc020_c">これ</a><br>
<p>
解説ページと同じような解説になるが...<br>
$P$ と $\overline {P}$ である $Q$ を作る。 <br>
$P$ は$A$ の整数を $0$ 個以上選んだ時の集合である。<br>
これらの総和を $\sum_P$, $\sum_Q$ としたとき、$\sum_P \leq \sum_Q$ であるように作る。<br>
$S_{2^N - 1}$ は $A$ すべての総和である。<br>
$\sum_P + \sum_Q = S_{2^N - 1}$ であるので、考えてみると、<br>
$\sum_Q \geq \frac{1}{2}S_{2^N - 1}$ であることが言えるだろう( $\sum_Q \lt \frac{1}{2}S_{2^N - 1}$だとすると、$\sum_P \gt \frac{1}{2}S_{2^N - 1}$ となり、$\sum_P \leq \sum_Q$ を満たさない) 。<br>
$P$ , $Q$ の数は $2^{N - 1}$ 個であり、 $P$ は $S$の定義にない空部分列を含んでいるため、 <br>
$\sum_P \leq S_{2^{N - 1} - 1}$ であり、$S_{2^{N - 1}} \leq \sum_Q \leq S_{2^{N} - 1} $ である。<br>
つまり $Q$ の最小を見つければいいわけだが、これは $\frac{1}{2}S_{2^N - 1}$ 以上の値なため、<br>
$\frac{1}{2}S_{2^N - 1}$ 以上の値の中で最小の値を見つければいいということになる。<br>
部分和のパターンは $2000 \times 2000$ より、 $4000000$ であることが制約から読み取れるので、<br>
$dp_{i,j}$ ($A_1$ から $A_i$ までの部分和で値 $j$ があるかどうか) を考える。<br>
$dp_{i,j}$ はbool値でいいので、bitsetを使って高速化する(また配列を使いまわせる)。<br>
DPのbitを$A_i$ 回シフトしたものとORすることによって簡単に遷移が可能である。<br>
そして$\frac{1}{2}S_{2^N - 1}$ から値があるかどうか調べ上げて、見つかったらそれを出力することでこの問題を解くことが出来る。<br>
計算量は $O(N^2max(A_i))$ ならしい。よくわからない。 普通に考えてこれはTLEしそうだけど、bitsetにより$64$ 倍高速化されて速い。<br>
<script src="https://gist.github.com/tinumu/02b10b71991be862563906090347dddc.js"></script>
よく見ると問題を解くまでに色々とフェーズがある。<br>
指数オーダーの( $N$ もでかい) 数列を作るならば、何か式を立てて(答えは普通の整数だろうから) 値で探索するというやり方をとるといいのかも...？
</p>
<h2> 感想 </h2>
<p> ちゃんと方針を立てないと問題が解けない奴ばっかなので、ちゃんと考えていきたい。</p>
</body>
</html>
