<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="../mainstyle.css">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>tinumuのホームページ</title>
</head>
<body>
<h1>データ抽象化</h1>
<h2>前書きみたいなもの</h2>
<p> Niklaus Wirth氏は<b>プログラム = アルゴリズム + データ構造</b>ということを言っていた。</p>
<p> プログラムはこの二つで成り立っているといっても過言ではないような感じだ。</p>
<p> アルゴリズムは、大まかにいうと処理手順(停止性・明確性・一般性の3種類を満たすようなもの)である。<br>
データ構造は、何か物理的な概念における値(例えば複素数とか)などの実装方法について言う。</p>

<p> まず、抽象化とは何か説明すると、<br>
<b>処理手順,実装方法などを隠して、機能のみに着目する考え方</b>だ（あってるかな…)。</p>
<br>
<p>
説明するところがないからアルゴリズムの抽象化についてここに書いておく。<br>
アルゴリズムの抽象化は、副手続き(Cでは関数)を利用して行う。<br>
これによって生じるメリットは、<br><br>
<b>・プログラム内に重複して存在する同一、あるいは似たような処理を一つにまとめる</b><br>
<b>・まとまりのある処理を他の部分とは明確に区別する(主に段階的詳細化などで使用する)</b><br>
<b>・共同でプログラムを作るために各人が独立してコーディング、デバッグ、テストを行うモジュールを形成する</b><br><br>
外部仕様を決めてあげることで、内部の実装方法と、その外部仕様に基づいたプログラミングを独立して行えるのだ。</br>
</p>
<h2>データ抽象化とは？</h2>
<p>データ抽象化とは<b>データの実現方法を考えずに、データの性質と振る舞いに着目してデータを設計すること</b>である。</p><br>

<p>ここでは、データが抽象化されていない状態から、完全な抽象化にまでもっていくプロセスを紹介しよう。</p>

<h3> 例 : 分数を扱う型Fraction </h3>

<p>ここでは、分数を扱う型Fractionを作り、少し操作を行わせてみることにする。</p>
<p>aとbの入力、これを掛け算してcに入れる。cを出力という感じだ。</p>

<script src="https://gist.github.com/tinumu/847892bc0dd385ecba0741dbbca6ce0e.js"></script>
<p> ざっとこんな感じ。</p>
<p> これは、Fraction型を定義しているものの、その<b>メリットを生かせていない。</b></p>
<p> main関数内で、Fraction型のint型のメンバ変数denominator と numeratorを<b>直に使用している</b>。<br>
このままではデータ型があるというだけで、操作はただのint型としての操作であり、<br>
<b>ただ変数名が冗長になっているだけ</b>になってしまう。</p>
<p> データを作る側、利用する側と考えた時に、<br>
「掛け算」、「入力」、「出力」を出来るように仕向けたのは紛れもなく今回は<b>「利用する側」</b>だった。</p>
<p> 分数には掛け算ができるという概念があるはずなのにそれを利用する側がいちいち作っててはおかしいだろう。</p>
<p> こういう、分数の性質と振る舞いで必要なものは、<b>「データを作る側」が用意しておく</b>必要があるのだ。
<br>
<p>ということで、このFraction型を操作する関数を整えてあげよう。利用者にとって使いやすくなるために。</p>
<ul>
<li> Fraction frcInput(); </li>
<li> void frcPrint(Fraction x); </li>
<li> Fraction frcMul(Fraction x, Fraction y) </li>
<li> Fraction frcReduction(Fraction x); </li>
</ul>
<p> 例えばこの4つの関数を用意してみる。</p>
<p>上から順に、分数を分子/分母の形で入力する、分数を分子/分母の形で出力する、分数を掛け算する、既約分数にするという関数である。</p>
<p>こういうデータに関する操作を行う関数のことを、<b>操作関数</b>という。</p>
<p>次のプログラムを、main関数に着目してみてほしい。</p>
<script src="https://gist.github.com/tinumu/2c88df4405c73c6575362a320aeba96a.js"></script>
<p> main関数はどうなっているだろうか。<br>
<b>メ　ン　バ　の　参　照　は　完　全　に　消　え　た　。</b>　やったぜ。</p>
<p> さて、main関数を弄っている利用者にとって、操作関数の内部仕様を理解する必要はあるだろうか。ないね。</p>
<p> 下に長々と書いてある操作関数の構造がどうであろうと、main関数はこの形で書けることが保証される。</p>
<p> これにより、<b>処理全体の見通しが良くなり、データの構造を隠すことができる。</b></p>

<p>データ抽象化するには、そのデータに対する<b>専用のデータ型・データを扱う関数(操作関数)</b>を用意することが必要であるということだ。</p>
<br>
<p>勘づく人もいると思うが、これにより、<b>データを利用する人と作る人を分離できる</b>のである。</p>
<p>これによって二者に生じるメリットがある。</p>
<p> 利用する側 : データの実装方法を知らなくても、データを利用することが出来る。<br>
作る側 : データの使い方(外部仕様)さえ変えなければ、データの実装方法を自由に選択・変更ができる</p>
<p>このような感じ。</p>
<br>
<p>で、ここでまた問題が生じる。</p>
<p><b>もしも、データ構造(メンバ変数など)を変えた場合どうなるだろうか。</b></p>
<p> 例えば、 numerator, denominatorじゃなくて、frc[2]などで表現するとか。</p>
<p> これは<b>操作関数全体に変更・修正を加えなければならなくなる。</b></p>
<p> プログラムはできるだけ、データの修正や変更に強くなる必要があるのだ。</p>
<br>
<p> ここで、一つ案が生まれる。</p>
<p> <b> 「データのメンバ変数などを取り出す関数、もしくはデータを作り出す関数を作ってしまえば、<br>
その部分の修正だけに収まるのでは？？？」</b>と。</p>
<p> そうなんですよーそれがあるんだなぁ…！！！</p>
<p>新たに関数を用意する。</p>
<ul>
<li> Fraction frcCreate(int numerator, int denominator) </li>
<li> int frcGetNumerator(Fraction x); </li>
<li> int frcGetDenominator(Fraction x); </li>
</ul>
<p>この三つの関数である。上から順に、<br>
numerator, demominatorから作られる分数を返す関数<br>
Fraction型xの分子を返す、Fraction型xの分母を返すという関数である。</p>
<p>この三つの関数を<b>基本操作関数(primitive function)</b>という。</p>
<p> 使い方を確認しよう。　操作関数に着目してみよう。</p>
<script src="https://gist.github.com/tinumu/d87e70b0fa67ed79d40d2ba41b9f8015.js"></script>
<p><b> お　わ　か　り　い　た　だ　け　た　だ　ろ　う　か　。 </b></p>
<p> 基本操作関数以外の操作関数では、一切メンバを使用しないということが！！！</p>
<p> こうすれば、メンバ変数の操作を最小限に抑えることが出来るため、変更や修正に強くなるということだ。</p>
<br>
<p> 操作関数には、データ構造に依存するものと、依存せずに実装できるものがあるということだ。</p>

<p> 基本操作関数の中でもデータ構造に依存するものが、<br>
構造体メンバの値を取り出す関数の<b>ゲッター(getter)</b>と、<br>
構造体メンバに値を格納する関数の<b>セッター(setter)</b>である。<br>
この2つを合わせて<b>アクセサー(accesser)</b>という。</p>
<p> 基本操作関数には、セッターを使用してセッターのような役割を持たせる関数などもある。</p>
<p> 上のプログラムのようにこのゲッターとセッターさえあれば、すべての操作関数は、<br>
構造体メンバを関数内で全く参照せずに実装することが出来る。</p>
<p>これにて、データ抽象化に基づいて表現したデータ型、すなわち<b>抽象データ型</b>を作成することが出来る。</p>
<p>抽象データ型は、<br>
・<b>データの持つ固有の性質やふるまいを表すデータ型名</b><br>
・<b>データを操作する関数</b><br>
を一体として扱う。</p>
<p> そのため、データを利用する側にとって、データ構造を操作する事はあり得ないということだ(そういうことだよね)。</p>

<h2> データ抽象化に基づいたプログラミング手順</h2>
<h3>まず</h3>
<p> ① データの性質を表す適切なデータ型(名)を決める。<br>
② ①で決めたデータ型を扱う操作関数の洗い出しと、その外部仕様の決定</p>
<p> ここで、データ構造や、操作関数の実装方法は一切考えないことにする。<br>
あと、ここで決めた外部仕様は<b>簡単に変更してはいけない！！！</b> 使っている人がやばいことに！！</p>
<h3>これが決まってしまえば…</h3>
<p>ここの外部仕様が決まってしまうと、アプリケーションプログラミングも抽象データ型の実装も平行して行える。</p>
<p>これは効率化のためでもあったのだ。いいことづくし。</p>
<p> 実装の方法としては、データ構造を決定して、そのあとに操作関数を実装をするという感じだ。</p>
<p> 抽象データ型の実装で留意すべきなのは、<b>基本操作関数以外は基本操作関数を用いて実装する</b>ということだ。<br>
外部仕様さえ変えなければデータの実装方法を自由に選択することが出来るため、パッといける。</p>
<p>通常、外部仕様の決定と、抽象データ型の設計、アプリケーションプログラミングは、異なる人(グループ)が行うため、<br>
このような設計をすれば、効率的かつ、人にやさしい感じのいいプログラムが作れるということだ!</p>
<p> 平行して行うことの素晴らしさ、抽象化されていることの安定さ、これが素晴らしさだ。</p>
<h2> まとめ </h2>
<p> データ抽象化は、大規模プログラムを作るうえでとっても大事だし、<br>
これによって、様々な概念を、プログラムに生成できるので、本当にありがとうございました。<br>
データ抽象化、好きです。素直に尊敬です。</p>
</div>
</body>
</html>
